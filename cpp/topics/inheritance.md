# Заметки про наследование

### Видимость и доступность

При работе с переменными и функциями стоит различать понятия
видимость и доступность.
Например когда мы помечаем некоторым модификатором _доступа_
переменную или функцию в классе, она не перестаёт быть видимой,
однако меняет свою доступность.

Давайте разберёмся, что при наследовании видимо(или нет), а что (не)доступно.

Рассмотрим такую ситуацию:
```
struct A {
  void f(int);
};
struct B : A {
  void f(double);
};
...
B b;
b.f(1);
```
Какая ```f``` вызовется?
Вызовется из ```B```, хотя кажется, что есть другая, которая подходит лучше.
А она не видна.
```f``` из ```A``` как раз доступна, но не видима, потому что 
```f(double)``` перекрывает ```f(int)``` будто переменная из более локальной
области видимости перекрывает переменную из более глобальной.
Т.е. во время поиска имён рассматриваются сначала все имена в наследнике,
а потом в родителе.

Аналогично с полями.
Если в обоих классах мы заведём поле ```int a;``` и напишем ```b.a = 1;```, 
мы будем иметь дело с ```a``` из класса ```B```.
Хотя на самом деле класс будет хранить два разных поля с одинаковым именем
```a```, одно из них будет не видно(но доступно).

А что делать, если мы хотим обратиться к конкретному полю или методу из наследника?
Надо явно указать область видимости:
```
b.A::f(1); // f(int)
b.A::a = 2;
```

Вот этот "приём", когда мы явно указываем область видимости, называется
*qualified id*, соответственно *unqualified id* - когда мы пишем через точку, 
не указывая область видимости.


