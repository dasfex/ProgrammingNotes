# Заметки про наследование

### Видимость и доступность

При работе с переменными и функциями стоит различать понятия
видимость и доступность.
Например когда мы помечаем некоторым модификатором _доступа_
переменную или функцию в классе, она не перестаёт быть видимой,
однако меняет свою доступность.

Давайте разберёмся, что при наследовании видимо(или нет), а что (не)доступно.

Рассмотрим такую ситуацию:
```
struct A {
  void f(int);
};
struct B: A {
  void f(double);
};
...
B b;
b.f(1);
```
Какая ```f``` вызовется?
Вызовется из ```B```, хотя кажется, что есть другая, которая подходит лучше.
А она не видна.
```f``` из ```A``` как раз доступна, но не видима, потому что 
```f(double)``` перекрывает ```f(int)``` будто переменная из более локальной
области видимости перекрывает переменную из более глобальной.
Т.е. во время поиска имён рассматриваются сначала все имена в наследнике,
а потом в родителе.

Аналогично с полями.
Если в обоих классах мы заведём поле ```int a;``` и напишем ```b.a = 1;```, 
мы будем иметь дело с ```a``` из класса ```B```.
Хотя на самом деле класс будет хранить два разных поля с одинаковым именем
```a```, одно из них будет не видно(но доступно).

А что делать, если мы хотим обратиться к конкретному полю или методу из наследника?
Надо явно указать область видимости:
```
b.A::f(1); // f(int)
b.A::a = 2;
```

Вот этот "приём", когда мы явно указываем область видимости, называется
*qualified id*, соответственно *unqualified id* - когда мы пишем через точку, 
не указывая область видимости.

Теперь другой пример:
```
struct A {
  void f(int);
  int a;
};
struct B: A {
 private:  
  void f(double);
  int a;
};
...
B b;
b.f(1);
```
Тут мы получим ошибку компиляции в силу того, что компилятор выбирает из видимых
имён наиболее подходящее, а уже потом, выбрав, смотрит, доступна ли эта функция.
Точно так же, если бы речь шла не о наследовании, а просто в классе было 2 функции:
одна от ```public int```, другая от ```private double```, - 
и в результате ```b.f(1.2)```, компилятор сначала выберет наиболее подходящую функцию,
а уже потом поймёт, что она недоступна, и кинет ошибку компиляции.
Т.е. он не будет выбирать менее подходящую, но более доступную.

Получили, что компилятор всегда сначала выбирает, что вызывать(смотрит видимость),
в уже потом проверяет, можно ли это вызвать(проверяет доступность).

### using в наследниках

А что если мы хотим, чтобы функции из класса ```А``` из  1ого примера участвовали в перегрузке
наравне с функциями из класса ```B```?

Тут можно использовать ```using```, чтобы добавить функции и поля в текущую область видимости:
```
using A::f;
```

### friend

Так же наследники или родители могут объявлять друг друга ```friend```, но стоит понимать, 
что это не наследуется и всё ещё работает в одну сторону.

### one more note

```
struct A {
  void f(int);
};
struct B: private A {
  void f(double);
};
struct C: B {
  void f() {
    B m; // так можно написать
    A g; // тут будет ошибка компиляции в силу того, что в контексте C
    // тип A означает C::A, но из-за такой цепочки наследования C::A нам недоступно,
    // потому что у C есть часть A, которая является приватной с точки зрения C
    // если мы хотим создать объект A, надо явно указать, что мы рассматриваем не часть
    // класса C, а глобальный тип:
    ::A g;
  }
};
```

Однако если в ```B``` написать ```friend struct C```, то теперь в ```C``` можно будет написать
```A g```, т.к. ```B``` открыл видимости для всего, что есть в себе.
Причём если написать ```friend struct C``` в ```A```, то это не поможет, потому что 
доступ перекрывает ```B```, а не ```A```.
  
