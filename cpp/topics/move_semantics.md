# Move-семантика

### Зачем это надо

1. Давайте рассмотри первую очевидную реализацию ```swap```:
```
template <class T>
void swap(T& x, T& y) {
  T t = x;
  x = y;
  y = t;
}
```
Очевидной проблемой является излишнее копирование(ведь в случае, если
```T``` - какой-то контейнер, то каждое присваивание тратит линейное время).

Да, у большинства контейнеров существует метод ```swap```(```v.swap(w)```),
но для каждого тяжеловесного контейнера писать такой метод как-то нерентабельно.

А представьте, если мы работаем с кастомными BigInt(которые сравниваются за линию).
И хотим отсортировать массив из таких ребят. 
Каждый такой ```swap``` будет занимать очень много времени.

2. Или давайте вспомним реализацию метода ```construct``` из аллокаторов:
```
void construct(T* p, const Args&... args) {
  new(p) T(args...);
}
```
И представим вот такую ситуацию:
```
vector<vector<int>> v;
v.push_back(vector<int>(1000000000));
```
Опуская все подробности работы ```push_back```, мы придём к тому, что
в реализации ```construct``` выше вызовется ```vector<int>(const vector<int>&)```,
т.е. конструктор копирования. Очень неприятно!

Да, конечно в таком случае можно использовать ```v.emplace_back(1000000000)```.
Тогда число будет передано в качестве аргументов, и не будет лишнего создания вектора.

Давайте представим, что у нас есть функция, возвращающая огромный вектор:
```
vector<int> f() {
  return vector<int>(1000000000);
}
...
v.push_back(f());
```
В таком случае не будет разницы между ```push_back``` и ```emplace_back```.
Придётся так и так копировать.

3. И проблема с использованием ```construct```(писали вот так):
```
traits::construct(alloc, newarr + i, arr[i]);
```
И здесь очень хочется сделать что-то более умное, чтобы не копировать
элемент.

Понятно, что в случае ```swap``` хотелось бы не просто копировать, 
а перекладывать все поля одного объекта в другой.
На примере вектора понятно, что проще переложить указатель на память, чем все элементы.

### Как надо писать, чтобы всё классно работало

Вот это правильная реализация ```swap``` для современных плюсов:
```
template <class T>
void swap(T& x, T& y) {
  T t = std::move(x);
  x = std::move(y);
  y = std::move(t);
}
```
```std::move``` просто перекладывает всё из одного объекта в другой(тот, из которого,
скорее всего становится невалидным).
Стоит понимать, что проблема 1 решена.
Но в реализации ```construct``` нельзя просто написать ```T(std::move(args)...)```,
ведь ```std::move``` инвалидирует объект, и каждый раз, когда мы клали бы что-то
в конец вектора, это становилось бы уничтоженным.
Т.е. писать ```std::move``` там нельзя, потому что будем ломать то,
что не хотели.
Но и не писать тоже нельзя: слишком долго будет работать.
Отложим эту проблему.

Давайте разберёмся, как работает то, что мы уже решили. 

### Как же реализованы конструкторы, что всё так работает

В C++11 появились новый вид конструкторов(move-конструктор).
Это конструктор, который принимает в качестве параметров нечто, что
возвращено после ```std::move```.
Давайте напишем его на примере вектора:
```
vector(vector<T>&& other) { // пока какой-то непонятный тип
  alloc = std::move(other.alloc);
  sz = other.sz;
  cp = other.cp;
  arr = other.arr;
  other.arr = nullptr;
} // по красоте надо через список инциализации
```

Аналогично пишется move-оператор присваивания.

### Когда стоит использовать конструктор перемещения

Давайте попробуем сформулировать правило, когда должен вызываться 
конструктор копирования, а когда конструктор перемещения, потому что 
понятно, что в перемещение хотелось бы отправлять не только результат
```std::move```.

Рассмотрим на примере BigInt.

Понятно, что вот такое выражение:
```
BigInt(BigInt())
```
надо бы мувать(вообще не совсем так, но чуть позже поправимся).

Или вот такое:
```
BigInt(x + y);
```
Или такое:
```
x++;
```
Но не такое:
```
++x;
```
Сформулируем правило: если выражение является lvalue, то вызовем конструктор копирования,
если rvalue, то перемещения.
Ровно это и делается.

### Что же такое rvalue/lvalue

lvalue включает в себя:
+ identifier(если выражение это просто идентификатор(просто имя переменной), 
то это lvalue(```x;```)), строковый литерал;
+ если функция возвращает reference return type(type&);
+ built-in operators: ```prefix ++, prefix --, =, op=, unary *```;
+ cast to lvalue-reference.

rvalue включает в себя:
+ любой литерал(кроме строкового);
+ если функция возвращает non-reference return type or rvalue-reference return type;
+ built-in operators: ```postfix ++, postfix --, +, -, /, *, %, <<, >>, &, |, ^, &&, ||,
==, <=, >=, <, >, !=, ~, !```;
+ cast to non-reference or rvalue-reference.

Оператор запятая имеет такой тип value, какой имеет последний операнд.

?: имеет такой, какой имеют оба возвращаемых типа, причём они должны быть одинаковыми, потому что
иначе возможна была бы ситуация ```(cond ? x : 5) = y```.

У операторов ```[]```, ```.```, ```->``` аналогично: к какому применяем, такое и получаем.

Давайте поймём, что же такое ```std::move```.

Название вводит в заблуждение: можно подумать, что она что-то перемещает, но на самом деле
она просто говорит трактовать текущий объект как rvalue-reference.

### rvalue-references properties

```
int x = 5;
int&& y; // просто вот так написать нельзя
int&& y = x; // вот так тоже нельзя, потому что справа lvalue
int&& y = std::move(x);
int&& y = static_cast<int&&>(x); // это два почти эквивалентных способа
int&& z = y; // так нельзя написать, ведь y lvalue, а нельзя биндить lvalue к rvalue-ссылкам
int& z = y; // так можно
```

### std::move

Давайте реализуем ```std::move```.

Для начала непонятно, что она должна возвращать и принимать.

Основная проблема в принимаемом значении.
Дело в том, что ```std::move``` должны уметь принимать как lvalue, так и rvalue объекты,
возвращая rvalue-ссылку.
Если мы передадим ```const T&```, то нет, потому что мы не можем биндить lvalue-ссылки
к временным объектам.
Если ```T&``` - не сможем вызывать функцию от временных объектов.
А если ```T&&``` - не сможем от невременных.

Для решения проблемы немного изменены правила вывода типов для шаблонных аргументов с 
двойным амперсандом. 
```
template <class T>
  move(T&&) {
  return static_cast
}
```
