# Move-семантика

### Зачем это надо

1. Давайте рассмотри первую очевидную реализацию ```swap```:
```
template <class T>
void swap(T& x, T& y) {
  T t = x;
  x = y;
  y = t;
}
```
Очевидной проблемой является излишнее копирование(ведь в случае, если
```T``` - какой-то контейнер, то каждое присваивание тратит линейное время).

Да, у большинства контейнеров существует метод ```swap```(```v.swap(w)```),
но для каждого тяжеловесного контейнера писать такой метод как-то нерентабельно.

А представьте, если мы работаем с кастомными BigInt(которые сравниваются за линию).
И хотим отсортировать массив из таких ребят. 
Каждый такой ```swap``` будет занимать очень много времени.

2. Или давайте вспомним реализацию метода ```construct``` из аллокаторов:
```
void construct(T* p, const Args&... args) {
  new(p) T(args...);
}
```
И представим вот такую ситуацию:
```
vector<vector<int>> v;
v.push_back(vector<int>(1000000000));
```
Опуская все подробности работы ```push_back```, мы придём к тому, что
в реализации ```construct``` выше вызовется ```vector<int>(const vector<int>&)```,
т.е. конструктор копирования. Очень неприятно!

Да, конечно в таком случае можно использовать ```v.emplace_back(1000000000)```.
Тогда число будет передано в качестве аргументов, и не будет лишнего создания вектора.

Давайте представим, что у нас есть функция, возвращающая огромный вектор:
```
vector<int> f() {
  return vector<int>(1000000000);
}
...
v.push_back(f());
```
В таком случае не будет разницы между ```push_back``` и ```emplace_back```.
Придётся так и так копировать.

3. И проблема с использованием ```construct```(писали вот так):
```
traits::construct(alloc, newarr + i, arr[i]);
```
И здесь очень хочется сделать что-то более умное, чтобы не копировать
элемент.

Понятно, что в случае ```swap``` хотелось бы не просто копировать, 
а перекладывать все поля одного объекта в другой.
На примере вектора понятно, что проще переложить указатель на память, чем все элементы.

### Как надо писать, чтобы всё классно работало

Вот это правильная реализация ```swap``` для современных плюсов:
```
template <class T>
void swap(T& x, T& y) {
  T t = std::move(x);
  x = std::move(y);
  y = std::move(t);
}
```
```std::move``` просто перекладывает всё из одного объекта в другой(тот, из которого,
скорее всего становится невалидным).
Стоит понимать, что проблема 1 решена.
Но в реализации ```construct``` нельзя просто написать ```T(std::move(args)...)```,
ведь ```std::move``` инвалидирует объект, и каждый раз, когда мы клали бы что-то
в конец вектора, это становилось бы уничтоженным.
Т.е. писать ```std::move``` там нельзя, потому что будем ломать то,
что не хотели.
Но и не писать тоже нельзя: слишком долго будет работать.
Отложим эту проблему.

Давайте разберёмся, как работает то, что мы уже решили. 

### Как же реализованы конструкторы, что всё так работает

В C++11 появились новый вид конструкторов(move-конструктор).
Это конструктор, который принимает в качестве параметров нечто, что
возвращено после ```std::move```.
Давайте напишем его на примере вектора:
```
vector(vector<T>&& other) { // пока какой-то непонятный тип
  alloc = std::move(other.alloc);
  sz = other.sz;
  cp = other.cp;
  arr = other.arr;
  other.arr = nullptr;
}
```



