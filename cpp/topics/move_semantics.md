# Move-семантика

### Зачем это надо

1. Давайте рассмотри первую очевидную реализацию ```swap```:
```
template <class T>
void swap(T& x, T& y) {
  T t = x;
  x = y;
  y = t;
}
```
Очевидной проблемой является излишнее копирование(ведь в случае, если
```T``` - какой-то контейнер, то каждое присваивание тратит линейное время).

Да, у большинства контейнеров существует метод ```swap```(```v.swap(w)```),
но для каждого тяжеловесного контейнера писать такой метод как-то нерентабельно.

А представьте, если мы работаем с кастомными BigInt(которые сравниваются за линию).
И хотим отсортировать массив из таких ребят. 
Каждый такой ```swap``` будет занимать очень много времени.

2. Или давайте вспомним реализацию метода ```construct``` из аллокаторов:
```
void construct(T* p, const Args&... args) {
  new(p) T(args...);
}
```
И представим вот такую ситуацию:
```
vector<vector<int>> v;
v.push_back(vector<int>(1000000000));
```
Опуская все подробности работы ```push_back```, мы придём к тому, что
в реализации ```construct``` выше вызовется ```vector<int>(const vector<int>&)```,
т.е. конструктор копирования. Очень неприятно!

Да, конечно в таком случае можно использовать ```v.emplace_back(1000000000)```.
Тогда число будет передано в качестве аргументов, и не будет лишнего создания вектора.

3. Давайте представим, что у нас есть функция, возвращающая огромный вектор.


