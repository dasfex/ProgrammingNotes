# Undefined behaviour(неопределённое поведение)

Неопределённое поведение — поведение, которое может возникать 
в результате использования ошибочных программных конструкций или некорректных данных, 
на которые Международный Стандарт не налагает никаких требований. 
Неопределенное поведение также может возникать в ситуациях, не описанных в Стандарте явно.

Тут я попробую собрать примеры очевидного(и не очень) неопределённого поведения в C++.

### Захват переменных в лямбда-функции

Давайте представим вот такую ситуацию:
```
class Div {
  int divisor;
  
 public:
  Div(int div) : divisor(div) {}

  auto get() {
    return [&](int n) {return n % divisor;};
  }
};
...
auto f = Div(10).get();
auto res = f(12);
```

Получаем ub.
Кажется, что тут очевидна проблема(захват переменных по ссылке).
Давайте исправим:
```
...
auto get() {
  return [=](int n) {return n % divisor;};
}
... 
```

Вроде как всё исправили.
Однако тут тоже ub.

Почему же?

Потому что время жизни переменной(```divisor```) меньше, чем время жизни лямюда-функции.

Вы скажете, что мы же захватили её по значению!
Но это неправда, ведь члены класса не захватываются лямбдой.
В таких случаях захватываются лишь значения в локальной области видимости функции,
потому при вызове ```f(12)``` ```divisor``` скорее всего не существует, что и ведёт к ub.

Поправить это можно вот так:
```
...
auto get() {
return [divisor = divisor](int n) {return n % divisor;};
}
...
```

### Ub при знаковом переполнении

Можно почитать вот [тут](https://codeforces.com/blog/entry/45144).

### Dangling reference

Возврат ссылки на несуществующй объект:
```
int& f(int x) {
  int y = x + 1;
  return y;
}
```
