# Аллокаторы

### Понятие аллокатора

Работать с памятью напрямую через операторы ```new, delete``` не принято.
Принято выполнять все подобные операции через класс-прослойку под названием аллокатор.

Что такое аллокатор?

Аллокатор - это шаблонный класс, предназначенный для выделения и удаления памяти 
под объекты данного типа.

Аллокатор должен представлять два метода: ```allocate, deallocate```.

```allocate``` принимает параметр ```n``` - кол-во штук объектов, 
на которые надо выделить память,
а ```deallocate``` принимает указатель и по историческим причинам ещё параметр ```size_t```
(позже разберёмся, что за он).

Стандартный аллокатор(```std::allocator<T>```) - просто прослойка, чтобы напрямую не писать 
```new```.

В большинстве контейнеров в шаблоне вы могли видеть аллокатор как параметр, 
т.е. его можно подменить своей реализацией с указанными методами.

Зачем это может быть нужно?

Стандартный аллокатор не соптимизирован под вашу программу. 
Выделение памяти делается ОС, а ОС не знает, 
куски какого размера наперёд вы собираетесь запрашивать.
Вы же, как разработчик, наперёд можете знать, какого вида запросы могут приходить,
и потому можете выбрать наиболее оптимальную стратегию выделения памяти.
И данную стратегию вы можете реализовать через аллокатор, подменив им стандартный.

> Как пример нестадартного аллокатора можно привести аллокатор, 
> который заранее выделяет огромный кусок памяти, а потом исходя из каких-то соображений
> отдаёт небольший кусочки памяти из этого большого пулла
> (например отдавать из самого левого, подходящего по размеру, или из самого большого куска).

Приведём примерную реализацию стандартного аллокатора:

```
namespace std {

template <class T>
struct allocator {
  T* allocate(size_t n) {
    return ::operator new(n * sizeof(T)); // вызываем глобальную функцию, 
					  // потому что не нужно вызывать констуктор
  }

  // по стандарту требуется, чтобы в deallocate передавалось 
  // то же самое size_t n, что приходило и в allocate
  // иначе ub
  void deallocate(T* p, size_t) { // тут его мы использовать не будем
    ::operator delete(p); // ос помнит, сколько байт выделила по конкретному указателю
  }
}

}
```

В принципе это почти все нужные методы для аллокатора, 
но на данном этапе мы только выделяем память,
а надо бы ещё вызывать конструктор.
Т.к. контейнер напрямую не может работать с ```new```, 
то у аллокатора ещё может быть метод ```construct```:

```
template <typename ...Args>
void construct(T* p, const Args& ...args) {
  new(p) T(args...);
}
```

Т.е. на выделенной памяти мы создаём объект с помощью данного метода.
Писать свой метод может понадобиться в случае, если мы например хотим 
логировать все подобные операции или запретить создавать объект с конкретными параметрами.

> На самом деле сигнатура у метода ```construct``` не совсем такая(как и вызов ```placement new```).
> Это мы исправим чуть позже, когда встретимся с некоторыми новыми проблемами move-семантики
> > !!!(add link to move-semantics)!!!.

Также стоит отметить, что реализация метода ```construct``` необязательна. 
И если вы не напишете его, контейнер некоторым образом проверит, реализован ли данный метод, 
и если нет, вызовет стандартный.
Как это делается, также разберём чуть позже.

По аналогии есть метод ```destroy```:

```
void destroy(T* p) {
  p->~T();
}
```

> Заметки:
> 
> 1. С точки зрения стандартного аллокатора все эти методы можно пометить ```const```.
> 
> ```allocate``` не может быть ```noexcept```, т.к. конструктор может бросить исключение.
> 
> ```deallocate``` конечно лучше ```noexcept``` не помечать, но можно сказать, что он 
> ```noexcept``` в зависимости от того, ```noexcept``` ли ```::operator delete(p)```.
> 
> ```construct``` можно пометить ```noexcept(noexcept(T(args...)))```.
> 
> ```destroy``` ```noexcept``` по умолчанию(деструкторы лучше именно так и помечать).
> 
> 2. В аллокаторе должен быть определён ```value_type```:
> 
> ```
> using value_type = T;
> ```
> 
> Это нужно, чтобы человек, использующий аллокатор, мог узнать, от чего данный аллокатор.

### allocator_traits

Мы рассмотрели 4 метода аллокаторов, 2 из которых обязательны, а 2 нет. 
Однако с С++17 ```construct``` и ```destroy``` у стандартного аллокатора уже не реализованы,
т.к. они реализованы на ещё одном уровне прослойки, которая занимается тем, чтобы
дореализовывать методы за аллокатором, которые нереализованны в нём самом.





