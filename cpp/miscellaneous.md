### FILE, LINE

Существует два макроса, с помощью которых можно узнавать
текущий файл(```__FILE__```) и текущую линию(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в GoogleTest.
// добавить пример

### Типы у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### using + template
Можно писать вот так:
```cpp
template <typename T>
using mi = map<int, T>;
...
mi<string> map_from_int_to_string;
```

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Ускорение std::stack

Известный факт, что ```std::stack``` является адаптером и по дефолту реализован на деке.
Это немного долговато. Чтобы ускорить, можно использовать в качестве базы ```std::vector```:
```cpp
std::stack<int, std::vector<int>> st;
```

### Ключ std::map и std::unordered_map

Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

### std::tie

Это конечно довольно базовое знание, но кажется, лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Решение выглядит так:
```cpp
delete p;
delete pp;
// or
delete p, delete pp; // но это какой-то говнокод :)
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### Как удобно писать оператор копирования/перемещения

Таким способом можно сократить это действие до трёх строчек.
И выглядит, как по мне, красиво :)
```cpp
class A {
 public:
  A(const A& a) {...}
  ~A() {...}
  
  A& operator=(const A& a) {
    this->~A(); // если без this, то скорее всего будет ругаться, что мы пытаемся инвертировать конструктор
    new(this) A(a);
    return *this;
  }
};
```
Можно конечно ещё проверить, не присваиваем ли мы объект самому себе.
Аналогично с перемещением.

### static_cast

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b = a;
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
