## Содержание
1. Макросы ```__FILE__```, ```__LINE__```.
2. Типы возвращаемых значений у тернарного оператора.
3. Счётчик в ```std::shared_ptr```.
4. ```using``` + ```template```.
5. Генерация имён для временных файлов.
6. Ускорение ```std::stack```.
7. Ключ в ```std::map``` и ```std::unordered_map```.
8. ```std::tie```.
9. Приоритет операторов.
10. ```static_cast```.
11. Cpp optimizations.
12. Определение pure virtual function.
13. Проблема параметров по умолчанию при наследовании.
14. User-defined deduction guides(since C++17).
15. Function-try block.
16. Перегрузка ```operator<<```.


### ```__FILE__```, ```__LINE__```

Существует два макроса, с помощью которых можно узнавать
текущий файл(```__FILE__```) и текущую линию(```__LINE__```).
Очень удобно использовать в каких-либо макросах для получения
дополнительной информации. 
Например, в GoogleTest.
// добавить пример

### Типы у тернарного оператора

Это кажется очевидным, но стоит помнить, что оба значения/выражения,
которые возвращает тернарный оператор должны быть одного типа, т.е.
писать вот так **нельзя**:
```cpp
auto val = condition ? "yes" : 0;
```
Более того, логично, если бы накладывалось требование на одинаковую категорию
value у возвращаемых типов.

### Счётчик в ```std::shared_ptr```

Я слышал два мнения:
+ Счётчик указателей на объект в ```std::shared_ptr``` является atomic.
+ ```std::shared_ptr``` сам по себе не очень хорошо ладит с многопоточностью.

[Уточнив](https://stackoverflow.com/questions/62784466/is-counter-in-stdshared-ptr-atomic),
стало понятно, что счётчик действительно atomic.
Получается, что копировать или делать ```move``` указателя 
в многопоточном приложении проблем не создаст, но стоит понимать, 
что сам объект, на который указывает ```std::shared_ptr```, никак от гонки за ресурсами
не защищён.

### ```using``` + ```template```
Можно писать вот так:
```cpp
template <typename T>
using mi = map<int, T>;
...
mi<string> map_from_int_to_string;
```

### Генерация имён для временных файлов

Для этих целей можно использовать [```std::tmpnam```](https://en.cppreference.com/w/cpp/io/c/tmpnam)
(правда оно немного небезопасно).

### Ускорение ```std::stack```

Известный факт, что ```std::stack``` является адаптером и по дефолту реализован на деке.
Это немного долговато. Чтобы ускорить, можно использовать в качестве базы ```std::vector```:
```cpp
std::stack<int, std::vector<int>> st;
```

### Ключ в ```std::map``` и ```std::unordered_map```

Ключ в ```std::map``` и ```std::unordered_map``` помечен как ```const```.
Вроде как это является интуитивным, потому что лично у меня никогда не возникало желания
изменять ключ в данных контейнерах, но есть и другая проблема, которая может возникнуть
из-за этого ограничения.

Предположим, что мы имеем
```cpp
std::map<MyType, other> mp;
```
и пробегаемся известной конструкцией с явным указанием типа пары:
```cpp
for (std::pair<MyType, other> x : mp) {}
```
Ни для кого не секрет, что тут будет копирование каждой пары.

Давайте рассмотрим вот такой код:
```cpp
for (const std::pair<MyType, other>& x : mp) {}
```
Вроде как мы всё исправили. 

А вот и нет!

В силу того, что ключ помечен ```const```, при получении по итератору пары из ```std::map```
будет произведён каст к указанному типу(а просто так скастовать не получится), 
что приведёт к лишнему копированию каждой пары.

Потому лучше всё-таки писать ```auto``` :)

### ```std::tie```

Это конечно довольно базовое знание, но кажется, лучше иногда напомнить.

Имеется вот такая структура:
```cpp
struct Student {
  std::string name;
  std::string surname;
  int year;
  int month;
  int day;
};
```

И мы хотим посортировать вектор таких чуваков в лексикографическом, заданном нами, порядке.

Вместо того, чтобы городить некрасивые конструкции из ифов, удобно сделать вот так:
```cpp
std::vector<Student> v;
...
std::sort(begin(v), end(v), [](auto l, auto r) {
  return std::tie(l.surname, l.name, l.year, l.month, l.day) < 
         std::tie(r.surname, r.name, r.year, r.month, r.day);
});
```

### Приоритет операторов

В целом неоднозначных случаев не возникает, но я встретил два момента, в которых
всё работает не так, как кажется.

1. Представим вот такой код:
```cpp
int* p = new int();
int* pp = new int();
delete p, pp;
```
Понятно, что ```pp``` не удалится! 
Ведь оператор ```delete``` является унарным и имеет приоритет выше, чем у 
оператора ```,```(запятая).

Если же написать:
```cpp
delete (p, pp);
```
то удалится только ```pp```, потому что оператор запятая возвращает последний операнд.

Решение выглядит так:
```cpp
delete p;
delete pp;
// or
delete p, delete pp; // но это какой-то говнокод :)
```

2. Вот такой код:
```cpp
int val;
...
if (val & 1 == 1) {
  ...
}
```
Тут интуитивно хотелось бы проверить последний бит числа ```val``` 
на равенство единице, но не получится:
приоритет оператора ```==``` выше, чем у ```&```(впрочем, как и у других
побитовых операторов).
Потому надо писать вот так:
```cpp
if ((val & 1) == 1) {
...
}
```

### ```static_cast```

Возможно вы думали, что можно кастовать типы с помощью ```static_cast``` 
только если они "одного рода"(например один числовой тип к другому).
На самом деле область шире.
Вы можете использовать его для приведения вот так:
```cpp
type1 a;
static_cast<type2>(a);
```
если можете писать вот так:
```cpp
type1 a;
type2 b = a;
```
Например:
```cpp
int x = 5;
auto v = static_cast<std::vector<int>>(x);
// now v = std::vector<int>{0, 0, 0, 0, 0}
```
Причём стоит понимать, что при таком касте создаётся копия объекта типа, к которому кастуют.

### Cpp optimizations.

1. EBCO.

```cpp
struct base {};
struct der: base {
  int a;
};
```
Чему будет равен ```sizeof(der)```? 
Зная, как работает наследование, создание пустого типа и выравнивание,
можно предположить, что 8 байт.
Однако в таких случаях происходит *Empty Base Class Optimization*:
если родитель является пустым, то его часть не создаётся в наследниках.
Т.е. ```sizeof(der)``` равен 4.

2. Return Value Optimization.

3. [SSO](https://stackoverflow.com/questions/3770781/why-is-sizeofstring-32).

### Определение pure virtual function

```cpp
struct A {
    virtual ~A() = 0;
};

A::~A() {} // доопределяем

struct B : public A {
  ~B() {}  
};
...
A* b = new B();
delete b;
```
При удалении ```b``` будет вызван сначала деструктор ```B```, а потом ```A```,
но деструктор у ```A``` является pure virtual и мы получим ```undefined reference to A::~A()```,
потому его нужно всё равно определить.

Как по мне, очень необычно :)

### Проблема параметров по умолчанию при наследовании

```cpp
struct A {
  virtual void f(int x = 1) const {
    std::cout << "A: " << x << '\n';
  }
};

struct B : A {
  void f(int x = 2) const override {
    std::cout << "B: " << x << '\n';
  }
};
...
const A& a = B();
a.f(); // result "B: 1"
```
Проблема в том, что концепция значений по умолчанию разрешается в compile time,
в то время как выбор перегрузки функции в runtime. 
Потому компилятор подставит значение 1 для переменной ```x``` на этапе компиляции, 
а в runtime уже выберет версию с подставленным параметром.

### User-defined deduction guides(since C++17)

В C++17 появилась возможность автовывода шаблонных типов, когда это возможно:
```cpp
std::vector v{1, 2, 3};
```
Рассмотрим пример:
```cpp
template <typename T>
struct S {
  S(T x) {}
};
...
S s("abs");
```
Тут тип ```T``` будет выведен как ```const char*```, но можно попросить компилятор
в таких случаях выводить его как ```std::string```.
Для этого после класса пишем:
```cpp
S(const char*) -> S<std::string>;
```
Можно также писать шаблонные подсказки:
```cpp
template <typename T>
S(const T&) -> S<T&>;
```

### Function-try block

Можно писать вот так:
```cpp
void f() try {

} catch (...) {
}
```
Понятно, что почти всегда такая форма эквивалентна:
```cpp
void f() {
  try {
  } catch (...) {
  }
}
```
Однако есть ситуация, когда их поведение различно: исключение в списке инициализации конструктора:
```cpp
struct S {
  std::string s;
  
  S(const std::string& s) try : s(s) {
  } catch (...) {}
};
```
Таким образом мы защищаемся от исключений при вызове конструктора ```s(s)```
(понятно, что тут такого не возникнет, но с кастомными классами легко).

Также можно делать с циклами. Например
```cpp
while () try {
} catch (...) {}
```

### Перегрузка ```operator<<```

Довольно понятный, но неочевидный факт, что ```operator<<``` можно перегружать не только
для потоков и их наследников, но я для любых кастомных объектов:
```cpp
struct A {
    vector<int> a;
};

A& operator<<(A& a, int x) {
    a.a.push_back(x);
    return a;
}
...
A a;
a << 1 << 2 << 3;
for (int x : a.a) {
    cout << x << ' ';
}
```
Как результат получим вывод ```1 2 3```.

Так, например, сделан ```QStringList``` в Qt.
