# Концепция написания LRU-кеша

LRU-кеш представляет из себя самую простую версию кеша,
которая хранит некоторое количество k последних запрошенных
значений.

Рассмотрим идею того, как можно эффективно реализовать 
такую структуру(этот подход является эффективным и находит
применение в других местах, например в хеш-таблицах).

Пусть мы хотим хранить некоторый тип T, который
должен быть хешируемым.

Будем хранить двусвязный список, который будет хранить
k последних запрошенных элементов, причём
чем ближе элемент к концу, тем раньше всего он запрашивался(
соответственно, чем ближе к началу, тем позже).
Заведём хеш таблицу, которая будет ставить в соответствие 
элементу итератор на ноду листа, в которой на данный момент
находится текущий элемент.
Как только мы получаем итератор на ноду, мы переставляем её
в начало листа.
Если же элемента в листе нет, удаляем последний элемент листа,
а в начало вставляем текущий.
Таким образом амортизированно за O(1) мы умеем делать все операции,
достигнув требуемого результат.

[C++](https://github.com/dasfex/ProgrammingPractice/blob/master/cpp/algos/lrucache.h),
[Golang](https://github.com/dasfex/ProgrammingPractice/blob/master/golang/lrucache.go).
